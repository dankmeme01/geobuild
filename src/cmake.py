from pathlib import Path
from dataclasses import dataclass, field
from enum import Enum
import hashlib

from .config import Config

__all__ = [
    "Privacy",
    "CMakeDefinition",
    "CMakeLibrary",
    "CMakeIncludeDir",
    "CMakeCompileOption",
    "CMakeLinkOption",
    "CMakeCacheVariable",
    "CMakeOption",
    "CMakePCH",
    "CMakeConfigure",
    "CMakeFile",
    "CPMDep",
    "truthy",
    "falsy"
]

class Privacy(Enum):
    PRIVATE = "PRIVATE"
    PUBLIC = "PUBLIC"
    INTERFACE = "INTERFACE"

@dataclass(frozen=True)
class CPMDep:
    name: str
    repo: str # always a URL
    tag: str
    options: dict[str, str]
    privacy: Privacy

@dataclass(frozen=True)
class CMakeDefinition:
    key: str
    value: str
    target: str | None
    privacy: Privacy

@dataclass(frozen=True)
class CMakeLibrary:
    name: str | Path
    privacy: Privacy
    target: str | None

@dataclass(frozen=True)
class CMakeIncludeDir:
    path: Path
    privacy: Privacy
    target: str | None

@dataclass(frozen=True)
class CMakeCompileOption:
    option: str
    privacy: Privacy
    target: str | None

@dataclass(frozen=True)
class CMakeLinkOption:
    option: str
    privacy: Privacy
    target: str | None

@dataclass(frozen=True)
class CMakeCacheVariable:
    key: str
    value: str
    type: str
    force: bool
    desc: str

@dataclass(frozen=True)
class CMakeOption:
    key: str
    default: bool
    desc: str

@dataclass(frozen=True)
class CMakePCH:
    headers: list[Path | str]
    privacy: Privacy
    target: str | None

@dataclass(frozen=True, unsafe_hash=True)
class CMakeConfigure:
    path: Path
    dest_path: Path
    copyonly: bool

def truthy(val: str) -> bool:
    return val.lower() in ("1", "true", "yes", "on", "y")

def falsy(val: str) -> bool:
    return val.lower() in ("0", "false", "no", "off", "n")

@dataclass
class CMakeFile:
    config: Config

    vars: dict[str, str]                 = field(default_factory=dict)
    cache_vars: dict[str, CMakeCacheVariable] = field(default_factory=dict)
    options: list[CMakeOption]           = field(default_factory=list)
    defs: dict[str, CMakeDefinition]     = field(default_factory=dict)
    messages: list[str]                  = field(default_factory=list)
    raw_statements: list[str]            = field(default_factory=list)
    configures: set[CMakeConfigure]      = field(default_factory=set)

    libraries: list[CMakeLibrary]        = field(default_factory=list)
    include_dirs: list[CMakeIncludeDir]  = field(default_factory=list)

    glob_dirs: set[tuple[Path, bool]]    = field(default_factory=set)
    source_files: set[Path]              = field(default_factory=set)
    pch: list[CMakePCH]                  = field(default_factory=list)

    deps: list[CPMDep]                   = field(default_factory=list)
    compile_options: list[CMakeCompileOption] = field(default_factory=list)
    link_options: list[CMakeLinkOption]       = field(default_factory=list)

    # def __init__(self, path: Path) -> None:
    #     self.path = path
    #     self.vars = {}
    #     self.defs = {}
    #     self.messages = []

    #     self.libraries = []
    #     self.include_dirs = []

    #     self.glob_dirs = set()
    #     self.source_files = set()

    #     self.deps = []
    #     self.options = []

    def convert_path(self, path: Path) -> str:
        sfx = None
        ret = ""

        if path.is_relative_to(self.config.build_dir):
            sfx = path.relative_to(self.config.build_dir)
            ret = f"\"{sfx}\""
        elif path.is_relative_to(self.config.project_dir):
            sfx = path.relative_to(self.config.project_dir)
            ret = f"\"${{CMAKE_SOURCE_DIR}}/{sfx}\""
        elif not path.is_absolute():
            sfx = self.config.project_dir / path
            ret = f'"{sfx.absolute()}"'
        else:
            ret = f'"{path}"'
        return ret.replace("\\", "/")

    def convert_header(self, hdr: Path | str) -> str:
        # is this an stl header?
        if isinstance(hdr, str) and hdr.startswith("<") and hdr.endswith(">"):
            return hdr

        return self.convert_path(Path(hdr))

    def export_str(self) -> str:
        def get_target(t: str | None) -> str:
            return t or self.config.project_name

        out = "# Generated by pre-build.py, DO NOT EDIT THIS FILE DIRECTLY\n\n"

        # Options
        for option in self.options:
            default_str = "ON" if option.default else "OFF"
            out += f'option({option.key} "{option.desc}" {default_str})\n'

        # Variables
        for key, value in self.vars.items():
            out += f"set({key} \"{value}\")\n"

        # Cache variables
        for key, cvar in self.cache_vars.items():
            cache_str = f"CACHE {cvar.type} "
            cache_str += f'"{cvar.desc}" '

            if cvar.force:
                cache_str += "FORCE "

            out += f'set({key} "{cvar.value}" {cache_str.strip()})\n'

        # Messages
        for message in self.messages:
            out += f'message(STATUS "{message}")\n'

        # Configures
        for conf in self.configures:
            out += f'configure_file({self.convert_path(conf.path)} {self.convert_path(conf.dest_path)}'
            if conf.copyonly:
                out += " COPYONLY"
            out += ")\n"

        # Sources
        out += "\n\n# Source files\n"
        out += "set(SOURCES \"\")\n"

        source_var_names = []

        for path, recursive in self.glob_dirs:
            converted = self.convert_path(path)
            hashed = hashlib.sha256(converted.encode()).hexdigest()[:16]

            name = f"SOURCES_{hashed}"
            assert name not in source_var_names, f"Duplicate source path: {converted}"

            source_var_names.append(name)
            glob_type = "GLOB_RECURSE" if recursive else "GLOB"
            out += f"file({glob_type} {name} CONFIGURE_DEPENDS {converted})\n"

        for name in source_var_names:
            out += f"list(APPEND SOURCES ${{{name}}})\n"

        for path in self.source_files:
            out += f"list(APPEND SOURCES {self.convert_path(path)})\n"

        # Add library
        out += f"\nadd_library({self.config.project_name} SHARED ${{SOURCES}})\n"
        out += f"set(_geobuild_project_name {self.config.project_name})\n"

        # CPM deps
        out += "\n# CPM Dependencies\n"
        for dep in self.deps:
            out += f"CPMAddPackage(\n"
            out += f'    NAME {dep.name}\n'
            out += f'    GIT_REPOSITORY "{dep.repo}"\n'
            out += f'    GIT_TAG "{dep.tag}"\n'
            if len(dep.options) > 0:
                out += f'    OPTIONS '
                for (opt_key, opt_value) in dep.options.items():
                    out += f'    "{opt_key} {opt_value}"\n'

            out += f")\n"

        # Definitions
        for key, cdef in self.defs.items():
            val_str = f"={cdef.value}"
            out += f"target_compile_definitions({get_target(cdef.target)} {cdef.privacy.name} {key}{val_str})\n"

        # Include dirs
        out += "\n# Include directories\n"
        for idir in self.include_dirs:
            out += f"target_include_directories({get_target(idir.target)} {idir.privacy.name} {self.convert_path(idir.path)})\n"

        # Compile options
        out += "\n# Compile options\n"
        for opt in self.compile_options:
            out += f"target_compile_options({get_target(opt.target)} {opt.privacy.name} \"{opt.option}\")\n"

        # Link options
        out += "\n# Link options\n"
        for opt in self.link_options:
            out += f"target_link_options({get_target(opt.target)} {opt.privacy.name} \"{opt.option}\")\n"

        # Precompile headers
        out += "\n# Precompiled headers\n"
        for pch in self.pch:
            headers_str = ' '.join([f'{self.convert_header(hdr)}' for hdr in pch.headers])
            out += f"target_precompile_headers({get_target(pch.target)} {pch.privacy.name} {headers_str})\n"

        # Links
        out += "\n# Linked libraries\n"
        for lib in self.libraries:
            if isinstance(lib.name, Path):
                name = self.convert_path(lib.name)
            elif '/' in lib.name or '\\' in lib.name:
                name = self.convert_path(Path(lib.name))
                print(f"Converting {lib.name} to path {name} for linking")
            else:
                name = lib.name

            out += f"target_link_libraries({get_target(lib.target)} {lib.privacy.name} {name})\n"

        # Raw statements
        out += "\n# Raw statements\n"
        for statement in self.raw_statements:
            out += f"{statement}\n"

        # call setup_geode_mod
        out += f"setup_geode_mod({self.config.project_name} LINK_TYPE PRIVATE)\n"

        return out

    def save(self, path: Path):
        path.write_text(self.export_str())
